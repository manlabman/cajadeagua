I'll guide you through creating a complete hematological counter using the PIC16F877A. This project integrates an 8-key counter, two control buttons, and three 7-segment displays.

ðŸ§¬ System Architecture Overview

Â· 8 Counting Keys: Each key press increments its specific counter.
Â· 2 Control Keys: RESET (clears all counts) and FUNCTION (toggles between showing raw counts and percentages).
Â· 3x7-Segment Displays: Multiplexed to show a 3-digit value (either a count or a percentage).
Â· PIC16F877A Port Allocation:
  Â· Port A (RA0-RA4): Controls the common cathodes/anodes of the three displays for multiplexing.
  Â· Port B (RB0-RB6): Outputs the segment patterns (a-g) for the displays.
  Â· Port C (RC0-RC7): Scans the 4x3 matrix for the 8 counting keys and 2 control keys.
  Â· Port D (RD0-RD1): Direct input for the two control keys (if not using the full matrix).

Here's a high-level view of the system's structure:

```mermaid
flowchart TD
    subgraph Hardware
        A[4x3 Key Matrix<br>8 Counting Keys + 2 Control Keys]
        B[PIC16F877A Microcontroller]
        C[3x Multiplexed<br>7-Segment Displays]
    end

    subgraph Firmware Flow
        Start[System Initialization] --> MainLoop
        MainLoop --> Scan
        Scan[Scan Key Matrix] --> KeyPressed{Key Detected?}
        KeyPressed -- Yes --> Debounce[Apply Debouncing Delay]
        Debounce --> Identify[Identify Key Function]
        Identify --> KeyType{Key Type?}

        KeyType -- Counting Key --> IncCounter[Increment Specific Counter]
        IncCounter --> UpdateDisplayFlag[Set Update Display Flag]

        KeyType -- Reset Key --> ClearAll[Clear All Counters & Totals]

        KeyType -- Function Key --> ToggleMode[Toggle View Mode<br>Counts â†” Percentages]

        KeyPressed -- No --> Bypass[Bypass Action]

        UpdateDisplayFlag --> UpdateDisplay
        ClearAll --> UpdateDisplay
        ToggleMode --> UpdateDisplay
        Bypass --> UpdateDisplay

        UpdateDisplay[Update Display Data] --> Calculate{Current Mode?}
        Calculate -- Percentages --> CalcPercent[Calculate Percentage<br>Key Count / Total * 100]
        Calculate -- Raw Counts --> GetCount[Fetch Raw Count Value]
        CalcPercent --> Format
        GetCount --> Format

        Format[Format for 3 Digits] --> Multiplex[Multiplex Display Output]
        Multiplex --> MainLoop
    end

    A -- Key Press Events --> B
    B -- Control Signals --> C
```

ðŸ’» Complete C Program (mikroC Pro for PIC)

This code implements the logic shown in the diagram.

```c
/* 
 *  Hematological Counter for PIC16F877A
 *  8 Counting Keys, Reset, Function Mode, 3x7-Segment Displays
 */

// PIC16F877A Configuration Bit Settings
__CONFIG(FOSC_XT & WDTE_OFF & PWRTE_ON & BOREN_ON & LVP_OFF & CPD_OFF & WRT_OFF & CP_OFF);

// Clock frequency for delay functions
#define _XTAL_FREQ 4000000

// Display configuration - ADJUST based on your hardware (Common Cathode example)
const unsigned short SEGMENT_PATTERNS[] = {
  0x3F, // 0
  0x06, // 1
  0x5B, // 2
  0x4F, // 3
  0x66, // 4
  0x6D, // 5
  0x7D, // 6
  0x07, // 7
  0x7F, // 8
  0x67  // 9
};

// Global Variables
unsigned int keyCount[8] = {0};      // Counts for keys 0-7
unsigned long totalPulses = 0;       // Total pulses across all keys
unsigned char displayMode = 0;       // 0=Show counts, 1=Show percentages
unsigned char displayDigits[3];      // Digits to display (hundreds, tens, units)

// Function Prototypes
void initPorts(void);
unsigned char scanKeys(void);
void updateDisplayData(unsigned char keyIndex);
void displayNumber(unsigned int number);
void multiplexDisplays(void);
void calculatePercentage(unsigned char keyIndex);

// Main Function
void main() {
  unsigned char keyPressed;
  unsigned char lastKey = 0xFF;      // For debounce tracking
  
  initPorts();                       // Configure I/O ports
  
  while(1) {
    keyPressed = scanKeys();         // Scan the key matrix
    
    if(keyPressed != 0xFF && keyPressed != lastKey) {
      __delay_ms(20);                // Debounce delay [citation:6]
      
      if(keyPressed == scanKeys()) { // Verify key is still pressed
        if(keyPressed < 8) {         // It's a counting key (0-7)
          keyCount[keyPressed]++;    // Increment specific counter
          totalPulses++;             // Increment total pulses
          updateDisplayData(keyPressed); // Prepare data for display
        }
        else if(keyPressed == 8) {   // RESET key (assigned index 8)
          // Reset all counts
          for(unsigned char i=0; i<8; i++) keyCount[i] = 0;
          totalPulses = 0;
          displayDigits[0] = 0;      // Show 000 on reset
          displayDigits[1] = 0;
          displayDigits[2] = 0;
        }
        else if(keyPressed == 9) {   // FUNCTION key (assigned index 9)
          // Toggle between counts and percentages
          displayMode = !displayMode;
          if(displayMode == 0) {
            // When switching to count mode, show first key's count
            updateDisplayData(0);
          } else {
            // When switching to percentage mode, show first key's percentage
            calculatePercentage(0);
          }
        }
      }
      lastKey = keyPressed;
    }
    else if(keyPressed == 0xFF) {
      lastKey = 0xFF;                // Reset when no key is pressed
    }
    
    multiplexDisplays();             // Continuously refresh displays
  }
}

// Initialize I/O Ports
void initPorts(void) {
  TRISA = 0x00;      // PORTA as output (display selection)
  TRISB = 0x00;      // PORTB as output (segment data)
  TRISC = 0xF0;      // PORTC: RC0-RC3 as output (rows), RC4-RC7 as input (cols) [citation:1]
  TRISD = 0x03;      // PORTD: RD0-RD1 as input (optional for separate reset/function keys)
  
  PORTA = 0x00;
  PORTB = 0x00;
  PORTC = 0x00;
  PORTD = 0x00;
}

// Scan 4x3 Key Matrix (8 counting + 2 control keys)
unsigned char scanKeys(void) {
  unsigned char row, col, keyValue = 0;
  
  for(row=0; row<3; row++) {           // Scan 3 rows
    PORTC = ~(1 << row);               // Activate one row at a time
    
    __delay_us(100);                   // Small stabilization delay
    
    // Read columns
    col = (PORTC >> 4) & 0x0F;
    
    // Check which column is active (low)
    if(!(col & 0x01)) return keyValue;     // Col 0
    keyValue++;
    if(!(col & 0x02)) return keyValue;     // Col 1
    keyValue++;
    if(!(col & 0x04)) return keyValue;     // Col 2
    keyValue++;
    if(!(col & 0x08)) return keyValue;     // Col 3
    keyValue++;
  }
  
  return 0xFF;  // No key pressed
}

// Prepare display data based on current mode
void updateDisplayData(unsigned char keyIndex) {
  if(displayMode == 0) {
    // Show raw count for the pressed key
    displayNumber(keyCount[keyIndex]);
  } else {
    // Show percentage for the pressed key
    calculatePercentage(keyIndex);
  }
}

// Format a number into three digits
void displayNumber(unsigned int number) {
  if(number > 999) number = 999;  // Cap at 999 for 3 digits
  
  displayDigits[0] = number / 100;                // Hundreds
  displayDigits[1] = (number % 100) / 10;         // Tens
  displayDigits[2] = number % 10;                 // Units
}

// Calculate and format percentage for a key
void calculatePercentage(unsigned char keyIndex) {
  unsigned int percentage = 0;
  
  if(totalPulses > 0) {
    // Calculate percentage: (count/total)*100
    percentage = (unsigned int)(((float)keyCount[keyIndex] / totalPulses) * 100.0);
  }
  
  displayNumber(percentage);  // Show as 3-digit number (0-100)
}

// Multiplex three 7-segment displays
void multiplexDisplays(void) {
  unsigned char displayIndex;
  
  for(displayIndex=0; displayIndex<3; displayIndex++) {
    PORTA = (1 << displayIndex);        // Select current display [citation:7]
    PORTB = SEGMENT_PATTERNS[displayDigits[displayIndex]];  // Send segment pattern [citation:6]
    
    __delay_ms(3);                      // Display ON time
    
    PORTB = 0x00;                       // Clear segments before switching display
  }
}
```

ðŸ”§ Hardware Implementation Guide

To build this system, you'll need to connect the following components correctly:

Key Components Needed:

Â· PIC16F877A microcontroller
Â· 3x Common Cathode 7-Segment Displays
Â· 4x3 Keypad Matrix (or 8 individual keys + 2 separate buttons)
Â· 3x NPN Transistors (2N2222 or BC547) for display multiplexing
Â· Current-limiting resistors: 8x 330Î© for display segments, 3x 1kÎ© for transistor bases
Â· Pull-up resistors: 10kÎ© for keypad columns
Â· 4MHz crystal oscillator with 22pF capacitors

Critical Hardware Notes:

1. Display Connections: Each display's common cathode connects to a transistor collector. Transistor bases connect to PORTA via 1kÎ© resistors.
2. Segment Connections: All display segments (a-g, dp) connect in parallel to PORTB, each through a 330Î© resistor.
3. Keypad Matrix: Connect rows to RC0-RC2, columns to RC4-RC7 with 10kÎ© pull-up resistors.
4. Power Supply: Ensure clean 5V power with proper decoupling capacitors (100nF ceramic near each IC).

ðŸ” Testing and Troubleshooting

Â· No Display Output: Verify transistor connections and base resistors. Check PORTB outputs with a multimeter.
Â· Incorrect Segment Lighting: Review the SEGMENT_PATTERNS[] array and match it to your display's pinout.
Â· Erratic Key Detection: Increase the debounce delay (try 30-50ms). Verify pull-up resistors on keypad columns.
Â· Display Flickering: Adjust the __delay_ms(3) in multiplexDisplays() to balance brightness and flicker.

To extend this system:

Â· Add an EEPROM module to store counts between power cycles.
Â· Implement a serial output (UART) to send data to a computer.
Â· Add audible feedback (buzzer) for key presses.
Â· Include LED indicators for current mode (count vs. percentage).

This hematological counter provides a solid foundation for medical counting applications. The modular design allows easy adaptation for different key quantities or display requirements.
